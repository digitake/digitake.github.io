---
layout: post
title:  "Type Inference ทำงานอย่างไร"
date:   2016-03-12 16:00:00 +0700
categories: Compiler Thai
---

หลังจากได้อ่าน [Function ในแบบ Haskell] ของคุณ Weerasak Chongnguluam ไปสะดุดเข้ากับประโยคนึง 

> Haskell มีกลไกที่เรียกว่า Type Inference เพื่อค้นหาได้เองว่า Type ที่เป็นไปได้ของ Function คืออะไร

จึงได้แรงบรรดาลใจอยากเขียนบล็อคเกี่ยวกับ Type Inference บ้าง เพราะจะเห็นได้ว่าระยะหลังฟีเจอร์หนึ่ง
ในภาษารุ่นใหม่ๆที่กลายเป็นฟีเจอร์ยอดฮิต ก็คือกลไกการเดา Type นั่นเอง

---


#### Type Inference คืออะไร
**Type Inference** คือกระบวนการให้เหตุผลแบบนิรนัยกับชนิดของตัวแปร ในภาษาโปรแกรม*ณ เวลาที่โปรแกรมถูกคอมไพล์*
เพื่อใช้เพิ่มประสิทธิภาพในการทำงานของโปรแกรมและทำให้เราเขียนโค้ดได้ง่ายขึ้น โดยเฉพาะโปรแกรมเชิงฟังก์ชั่น

---


#### ถ้าไม่มีแล้วเป็นยังไง?
เริ่มจากลองจินตนาการถึงภาษาที่ไม่มี **Type Inference** อย่างเช่น Java*(จริงๆแล้วมีในรูปแบบ Generics)* ในจาวานั้นเราจำเป็นต้องระบุชนิดของตัวแปรทุกตัว
เพื่อให้คอมไพล์เลอร์สามารถสร้าง Symbol Table(ตารางสัญลักษณ์เพื่อช่วยในการคอมไพล์) ได้ถูกต้อง โดยรูปแบบทั่วไปที่พวกเราคุ้นเคยกันดีก็คือ
        
```java
<ไทป์> <ชื่อตัวแปร> = new <คอนสตรัคเตอร์>;
//ตัวอย่างเช่น
String s = new String("abc"); //โดยปกติแล้วเราย่อเหลือแค่ String s = "abc"; แต่ขอให้เข้าใจว่ามันคือรูปแบบย่อ
Object o = new Object();
```
    
แม้ว่าส่วนใหญ่แล้วไทป์ที่เราใช้กับคอนสครัคเตอร์มักจะเป็นตัวเดียวกัน แต่เราไม่สามารถย่อรูปแบบได้มากกว่านี้เนื่องจากมีโอกาสที่ instance จะเป็น subtype เช่น


```java
Object o = new String("I'm object too");
```

ซึ่งการใช้งานในลักษณะนี้อันที่จริงแล้วเป็นความสามารถที่สำคัญของจาวาที่ทำให้เกิด Polymorphism เนื่องจากไทป์จะการันตีว่าตัวแปรนั้นจะมี methods/vars อยู่แน่ๆ(ถ้าไม่มีคอมไพล์ไม่ผ่านเกิด *Incompatible type error*)
ตัวอย่างสุดคลาสสิคเช่นกำหนดให้ Circle, Square, Triangle เป็น Subtype ของ Shape และ Shape มี method draw อยู่ ดังนั้นเราจะทำแบบนี้ได้

```java
Shape s = new Circle();
s.draw();
s = new Square();
s.draw();
s = new Triangle();
s.draw();
```

รูปแบบนี้ทำให้เราเขียนโค้ดได้สะดวก แต่แลกมาด้วย overhead และความยุ่งยากในการเขียนเนื่องจากต้องระบุไทป์ให้กับตัวแปรทุกตัว

---


#### ทำไมต้องมี?
ภาษาแบบไม่มี Type Inference นั้นก็ไม่ได้เลวร้ายอะไรหากเขียนในแบบ Imperative แต่จะเป็นปัญหาอย่างมากหากต้องการเขียนแบบ Functional เนื่องจากการระบุ Type นั้นต้องอาศัย
**การประกาศ** แต่ว่าแนวทางการเขียนโปรแกรมเชิงฟังก์ชั่นนั้นจะต้อง **ส่งผ่าน** และฟังก์ชั่นทุกฟังก์ชั่นควรจะส่งค่ากลับ แต่หากลองยกตัวอย่างการประกาศไทป์ `String s` คำถามที่เกิดคือ
เราควรจะส่งค่าอะไรกลับ?

ดังนั้นเห็นได้ว่าเกิดความไม่สะดวกขึ้นอย่างมากเมื่อโปรแกรมถูกจำกัดให้มีแต่นิพจน์(expression) ซึ่งเป็นธรรมชาติของการเขียนโปรแกรมเชิงฟังก์ชั่น

---


#### Type inference vs dynamic type
ทางออกสำหรับการสร้างภาษาที่เราสามารถละเว้นการประกาศชนิดตัวแปรมีอยู่สองแนวทาง 

- อันแรกคือการเพิ่ม Type information ไปกับ Symbol table โดยผลลัพธ์ที่ได้ก็คือ
ภาษาที่มีลักษณะแบบ Dynamically-typed เช่น Python, Ruby, Javascript ข้อดีก็คือสามารถสร้าง 
Compiler ได้ง่าย แต่ข้อเสียคือจะต้องเสีย overhead ทุกครั้งในการดำเนินการเนื่องจาก type-checking
จะต้องทำงานในช่วง run-time ด้วย

- อันที่สองคือการใช้ Type inference ซึ่งคือเป้าหมายที่เราจะพูดถึงในบทความนี้ โดยกระบวนการนี้จะใช้การให้
เหตุผลเชิงนิรนัยในการหาข้อสรุปจากตัวโค้ดเอง ตัวอย่างเช่น

```haskell
x = 1
```

จากตัวอย่างจะเห็นว่าเรา(โปรแกรมเมอร์)สามารถให้เหตุผลได้ง่ายๆว่า x ควรจะต้องเป็นตัวแปรชนิด int เนื่องจาก 1 เป็น int นั่นเอง
และเราไม่ต้องรอให้โปรแกรมทำงานก่อนจึงจะทราบ แต่เราสามารถอ่านโค้ดแล้วเข้าใจได้ทันที
ข้อนี้จะทำให้เราเข้าใจอีกประเด็นคือ **Type inference** นั้นจะทำงานกับภาษาโปรแกรมที่เป็น Statically-typed นั่นคือชนิดไทป์ของตัวแปร
จะถูกตีความตั้งแต่ช่วงเวลาคอมไพล์

---


#### The most general type
**Type inference** สมัยใหม่โดยมากจะให้ไทป์ผลลัพธ์เป็น **the most general type** ซึ่งก็คือไทป์ที่ใหญ่ที่สุดที่จะบรรจุค่าในขนาดที่โปรแกรมทำงานได้
ยกตัวอย่างเช่น

```haskell
map f [] = []
map f (first:rest) = f first : map f rest
```

จากตัวอย่างสิ่งที่เกิดขึ้นจากการทำ **Type inference** สรุปเป็นขั้นตอนได้ดังนี้

1. map ถูกตีความว่าเป็น function `a -> b -> c` โดยทราบจากรูปแบบ Syntax เป็นรูปแบบการนิยามฟังก์ชั่น
2. [] และ (first:rest) เป็นรูปแบบของ list ดังนั้นเราให้เหตุผลได้ว่า b จะต้องเป็น list ของไทป์อะไรสักอย่าง d ( `b = [d]` )
3. f จะต้องเป็นฟังก์ชั่นที่รับข้อมูลไทป์ d เนื่องจากมีการ `f first` ส่งค่า first ให้กับ f โดยเราทราบว่า first มีไทป์ d
4. ผลลัพธ์ของ `f first` จะให้ไทป์อะไรสักอย่าง e หรือ f มีไทป์เป็น `d -> e` นั่นเอง
5. สรุปจาก (2) และ (4) ตอนนี้เราจะทราบว่า map มีไทป์เป็น `(d -> e) -> [d] -> [e]`
6. ชื่อตัวแปรไทป์ไม่มีความหมายดังนั้นเราสามารถเปลี่ยนมันเป็น a b c ได้ สรุปเราจะได้ `map :: (a->b)->[a]->[b]`

ผลลัพธ์ที่ได้นี้จะเห็นว่า ไทป์ของ map เป็น **the most general type** คือสามารถทำงานกับ a,b,c ใดๆก็ได้

---


#### ทำงานยังไง: Unification and Substitution
ในการทำงานจริงโดยมากเราใช้ [Algorithm W] ซึ่งเป็นผลงานของ Hindley-Milner Type inference
แต่หัวใจหลักในการทำงานอยู่ที่คอนเซปง่ายๆในการ **รวมและแทนค่า(Unification and Substitution)**
โดยตัว unification คือการพยายามหาจุดร่วมของไทป์โดยการขยับขึ้นข้างบน และ substitution คือการทดลองแทนที่ด้วยไท์ืที่จะทำให้เงื่อนไข
สอดคล้องกับไทป์ทั้งหมด

ตัวอย่าง algorithm unify จาก <https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W>

```
unify(ta,tb):
  ta = find(ta)
  tb = find(tb)
  if both ta,tb are terms of the form D p1..pn with identical D,n then
    unify(ta[i],tb[i]) for each corresponding ith parameter
  else
  if at least one of ta,tb is a type variable then
    union(ta,tb)
  else
    error 'types do not match'
```

หากผู้อ่านสนใจศึกษารายละเอียดสามารถใช้ Keywords: Type inference, Hindley-Milner, Unification, Algorithm W เพิ่มเติมได้ครับ

[Function ในแบบ Haskell]:https://medium.com/p/c403a9a2a7e9
[Algorithm W]:http://catamorph.de/documents/AlgorithmW.pdf
[HM Implementation in Haskell]:http://dev.stephendiehl.com/fun/006_hindley_milner.html